// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: cosmonova/cosmonova/proof.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	github_com_tendermint_tendermint_libs_bytes "github.com/tendermint/tendermint/libs/bytes"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// BlockHeaderMerkleParts stores a group of hashes using for computing Tendermint's block
// header hash from app hash, and height.
//
// In Tendermint, a block header hash is the Merkle hash of a binary tree with 14 leaf nodes.
// Each node encodes a data piece of the blockchain. The notable data leaves are: [A] app_hash,
// [2] height. All data pieces are combined into one 32-byte hash to be signed
// by block validators. The structure of the Merkle tree is shown below.
//
//	                                 [BlockHeader]
//	                              /                \
//	                 [3A]                                    [3B]
//	               /      \                                /      \
//	       [2A]                [2B]                [2C]                [2D]
//	      /    \              /    \              /    \              /    \
//	  [1A]      [1B]      [1C]      [1D]      [1E]      [1F]        [C]    [D]
//	  /  \      /  \      /  \      /  \      /  \      /  \
//	[0]  [1]  [2]  [3]  [4]  [5]  [6]  [7]  [8]  [9]  [A]  [B]
//
//	[0] - version               [1] - chain_id            [2] - height        [3] - time
//	[4] - last_block_id         [5] - last_commit_hash    [6] - data_hash     [7] - validators_hash
//	[8] - next_validators_hash  [9] - consensus_hash      [A] - app_hash      [B] - last_results_hash
//	[C] - evidence_hash         [D] - proposer_address
//
// Notice that NOT all leaves of the Merkle tree are needed in order to compute the Merkle
// root hash, since we only want to validate the correctness of [2], [3], and [A]. In fact, only
// [1A], [2B], [1E], [B], and [2D] are needed in order to compute [BlockHeader].
type BlockHeaderMerkleParts struct {
	VersionAndChainIdHash             github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,1,opt,name=version_and_chain_id_hash,json=versionAndChainIdHash,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"version_and_chain_id_hash,omitempty"`
	Height                            uint64                                               `protobuf:"varint,2,opt,name=height,proto3" json:"height,omitempty"`
	TimeSecond                        uint64                                               `protobuf:"varint,3,opt,name=time_second,json=timeSecond,proto3" json:"time_second,omitempty"`
	TimeNanoSecond                    uint32                                               `protobuf:"varint,4,opt,name=time_nano_second,json=timeNanoSecond,proto3" json:"time_nano_second,omitempty"`
	LastBlockIdAndOther               github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,5,opt,name=last_block_id_and_other,json=lastBlockIdAndOther,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"last_block_id_and_other,omitempty"`
	NextValidatorHashAndConsensusHash github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,6,opt,name=next_validator_hash_and_consensus_hash,json=nextValidatorHashAndConsensusHash,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"next_validator_hash_and_consensus_hash,omitempty"`
	LastResultsHash                   github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,7,opt,name=last_results_hash,json=lastResultsHash,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"last_results_hash,omitempty"`
	EvidenceAndProposerHash           github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,8,opt,name=evidence_and_proposer_hash,json=evidenceAndProposerHash,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"evidence_and_proposer_hash,omitempty"`
}

func (m *BlockHeaderMerkleParts) Reset()         { *m = BlockHeaderMerkleParts{} }
func (m *BlockHeaderMerkleParts) String() string { return proto.CompactTextString(m) }
func (*BlockHeaderMerkleParts) ProtoMessage()    {}
func (*BlockHeaderMerkleParts) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaa32ed1d8f589d4, []int{0}
}
func (m *BlockHeaderMerkleParts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *BlockHeaderMerkleParts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_BlockHeaderMerkleParts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *BlockHeaderMerkleParts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BlockHeaderMerkleParts.Merge(m, src)
}
func (m *BlockHeaderMerkleParts) XXX_Size() int {
	return m.Size()
}
func (m *BlockHeaderMerkleParts) XXX_DiscardUnknown() {
	xxx_messageInfo_BlockHeaderMerkleParts.DiscardUnknown(m)
}

var xxx_messageInfo_BlockHeaderMerkleParts proto.InternalMessageInfo

func (m *BlockHeaderMerkleParts) GetVersionAndChainIdHash() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.VersionAndChainIdHash
	}
	return nil
}

func (m *BlockHeaderMerkleParts) GetHeight() uint64 {
	if m != nil {
		return m.Height
	}
	return 0
}

func (m *BlockHeaderMerkleParts) GetTimeSecond() uint64 {
	if m != nil {
		return m.TimeSecond
	}
	return 0
}

func (m *BlockHeaderMerkleParts) GetTimeNanoSecond() uint32 {
	if m != nil {
		return m.TimeNanoSecond
	}
	return 0
}

func (m *BlockHeaderMerkleParts) GetLastBlockIdAndOther() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.LastBlockIdAndOther
	}
	return nil
}

func (m *BlockHeaderMerkleParts) GetNextValidatorHashAndConsensusHash() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.NextValidatorHashAndConsensusHash
	}
	return nil
}

func (m *BlockHeaderMerkleParts) GetLastResultsHash() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.LastResultsHash
	}
	return nil
}

func (m *BlockHeaderMerkleParts) GetEvidenceAndProposerHash() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.EvidenceAndProposerHash
	}
	return nil
}

// MultiStoreProof stores a compact of other Cosmos-SDK modules' storage hash in multistore to
// compute (in combination with oracle store hash) Tendermint's application state hash at a given block.
//
//	                                           ________________[AppHash]_________________________
//	                                          /                                                  \
//	                      _________________[N15]_________________                             __[N16]___
//	                     /                                        \                          /          \
//	          _______[N12]______                          _______[N13]________             [N14]        [I]
//	         /                  \                        /                    \           /     \
//	    __[N8]__             __[N9]__                __[N10]__              __[N11]__    [G]   [H]
//	   /         \          /         \            /          \            /         \
//	  [N0]       [N1]      [N2]       [N3]       [N4]        [N5]         [N6]       [N7]
//	/     \     /    \    /    \     /     \     /     \     /     \     /     \     /    \
//
// [0]   [1]  [2]   [3] [4]   [5]  [6]    [7]  [8]    [9]  [A]    [B]  [C]    [D]  [E]   [F]
//
// [0] - acc (auth) [1] - authz    [2] - bank     [3] - capability [4] - crisis   [5] - dist
// [6] - evidence   [7] - feegrant [8] - gov      [9] - group      [A] - ibccore    [B] - icahost
// [C] - mint       [D] - oracle   [E] - params   [F] - slashing   [G] - staking    [H] - transfer [I] - upgrade
// Notice that NOT all leaves of the Merkle tree are needed in order to compute the Merkle
// root hash, since we only want to validate the correctness of [D] In fact, only
// [C], [N7], [N10], [N12], and [N16] are needed in order to compute [AppHash].
type MultiStoreProof struct {
	OracleIAVLStateHash              github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,1,opt,name=oracle_iavl_state_hash,json=oracleIavlStateHash,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"oracle_iavl_state_hash,omitempty"`
	MintStoreMerkleHash              github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,2,opt,name=mint_store_merkle_hash,json=mintStoreMerkleHash,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"mint_store_merkle_hash,omitempty"`
	ParamsToSlashingStoresMerkleHash github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,3,opt,name=params_to_slashing_stores_merkle_hash,json=paramsToSlashingStoresMerkleHash,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"params_to_slashing_stores_merkle_hash,omitempty"`
	GovToIcahostStoresMerkleHash     github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,4,opt,name=gov_to_icahost_stores_merkle_hash,json=govToIcahostStoresMerkleHash,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"gov_to_icahost_stores_merkle_hash,omitempty"`
	AuthToFeegrantStoresMerkleHash   github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,5,opt,name=auth_to_feegrant_stores_merkle_hash,json=authToFeegrantStoresMerkleHash,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"auth_to_feegrant_stores_merkle_hash,omitempty"`
	StakingToUpgradeStoresMerkleHash github_com_tendermint_tendermint_libs_bytes.HexBytes `protobuf:"bytes,6,opt,name=staking_to_upgrade_stores_merkle_hash,json=stakingToUpgradeStoresMerkleHash,proto3,casttype=github.com/tendermint/tendermint/libs/bytes.HexBytes" json:"staking_to_upgrade_stores_merkle_hash,omitempty"`
}

func (m *MultiStoreProof) Reset()         { *m = MultiStoreProof{} }
func (m *MultiStoreProof) String() string { return proto.CompactTextString(m) }
func (*MultiStoreProof) ProtoMessage()    {}
func (*MultiStoreProof) Descriptor() ([]byte, []int) {
	return fileDescriptor_eaa32ed1d8f589d4, []int{1}
}
func (m *MultiStoreProof) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *MultiStoreProof) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_MultiStoreProof.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *MultiStoreProof) XXX_Merge(src proto.Message) {
	xxx_messageInfo_MultiStoreProof.Merge(m, src)
}
func (m *MultiStoreProof) XXX_Size() int {
	return m.Size()
}
func (m *MultiStoreProof) XXX_DiscardUnknown() {
	xxx_messageInfo_MultiStoreProof.DiscardUnknown(m)
}

var xxx_messageInfo_MultiStoreProof proto.InternalMessageInfo

func (m *MultiStoreProof) GetOracleIAVLStateHash() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.OracleIAVLStateHash
	}
	return nil
}

func (m *MultiStoreProof) GetMintStoreMerkleHash() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.MintStoreMerkleHash
	}
	return nil
}

func (m *MultiStoreProof) GetParamsToSlashingStoresMerkleHash() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.ParamsToSlashingStoresMerkleHash
	}
	return nil
}

func (m *MultiStoreProof) GetGovToIcahostStoresMerkleHash() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.GovToIcahostStoresMerkleHash
	}
	return nil
}

func (m *MultiStoreProof) GetAuthToFeegrantStoresMerkleHash() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.AuthToFeegrantStoresMerkleHash
	}
	return nil
}

func (m *MultiStoreProof) GetStakingToUpgradeStoresMerkleHash() github_com_tendermint_tendermint_libs_bytes.HexBytes {
	if m != nil {
		return m.StakingToUpgradeStoresMerkleHash
	}
	return nil
}

func init() {
	proto.RegisterType((*BlockHeaderMerkleParts)(nil), "cosmonova.cosmonova.BlockHeaderMerkleParts")
	proto.RegisterType((*MultiStoreProof)(nil), "cosmonova.cosmonova.MultiStoreProof")
}

func init() { proto.RegisterFile("cosmonova/cosmonova/proof.proto", fileDescriptor_eaa32ed1d8f589d4) }

var fileDescriptor_eaa32ed1d8f589d4 = []byte{
	// 657 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x95, 0xcd, 0x6e, 0x13, 0x3b,
	0x14, 0xc7, 0x3b, 0xfd, 0xc8, 0xbd, 0xf2, 0xbd, 0x50, 0x98, 0x42, 0x1a, 0x0a, 0x4a, 0xd2, 0x22,
	0x50, 0x56, 0xc9, 0x02, 0x90, 0xd8, 0x26, 0x48, 0xa8, 0x91, 0x28, 0xad, 0x92, 0xd0, 0x05, 0x1b,
	0xcb, 0x19, 0x9f, 0xce, 0x58, 0x9d, 0xf8, 0x8c, 0x6c, 0xcf, 0xa8, 0x5d, 0x22, 0xc1, 0x02, 0xb1,
	0xe1, 0x3d, 0x78, 0x11, 0xc4, 0xaa, 0x4b, 0x56, 0x15, 0x4a, 0xdf, 0x82, 0x15, 0xb2, 0x67, 0xd2,
	0x06, 0x9a, 0x15, 0xb3, 0x3b, 0x73, 0x6c, 0xff, 0x7f, 0xff, 0x73, 0xc6, 0x1f, 0xa4, 0x11, 0xa0,
	0x9e, 0xa0, 0xc4, 0x8c, 0x75, 0xae, 0xa2, 0x44, 0x21, 0x1e, 0xb5, 0x13, 0x85, 0x06, 0xfd, 0x8d,
	0xcb, 0x74, 0xfb, 0x32, 0xda, 0x6a, 0x2e, 0x5a, 0x95, 0xb1, 0x38, 0x05, 0x9d, 0x2f, 0xdb, 0xba,
	0x13, 0x62, 0x88, 0x2e, 0xec, 0xd8, 0x28, 0xcf, 0xee, 0x7c, 0x5b, 0x23, 0xd5, 0x5e, 0x8c, 0xc1,
	0xf1, 0x2e, 0x30, 0x0e, 0x6a, 0x0f, 0xd4, 0x71, 0x0c, 0x07, 0x4c, 0x19, 0xed, 0x2b, 0x72, 0x2f,
	0x03, 0xa5, 0x05, 0x4a, 0xca, 0x24, 0xa7, 0x41, 0xc4, 0x84, 0xa4, 0x82, 0xd3, 0x88, 0xe9, 0xa8,
	0xe6, 0x35, 0xbd, 0xd6, 0xff, 0xbd, 0xe7, 0x3f, 0xcf, 0x1b, 0x4f, 0x43, 0x61, 0xa2, 0x74, 0xdc,
	0x0e, 0x70, 0xd2, 0x31, 0x20, 0x39, 0xa8, 0x89, 0x90, 0x66, 0x3e, 0x8c, 0xc5, 0x58, 0x77, 0xc6,
	0xa7, 0x06, 0x74, 0x7b, 0x17, 0x4e, 0x7a, 0x36, 0x18, 0xdc, 0x2d, 0xa4, 0xbb, 0x92, 0xbf, 0xb0,
	0xc2, 0x7d, 0xbe, 0xcb, 0x74, 0xe4, 0x57, 0x49, 0x25, 0x02, 0x11, 0x46, 0xa6, 0xb6, 0xdc, 0xf4,
	0x5a, 0xab, 0x83, 0xe2, 0xcb, 0x6f, 0x90, 0xff, 0x8c, 0x98, 0x00, 0xd5, 0x10, 0xa0, 0xe4, 0xb5,
	0x15, 0x37, 0x48, 0x6c, 0x6a, 0xe8, 0x32, 0x7e, 0x8b, 0xdc, 0x72, 0x13, 0x24, 0x93, 0x38, 0x9b,
	0xb5, 0xda, 0xf4, 0x5a, 0x37, 0x06, 0x37, 0x6d, 0xfe, 0x35, 0x93, 0x58, 0xcc, 0x94, 0x64, 0x33,
	0x66, 0xda, 0xd0, 0xb1, 0xad, 0xda, 0xd6, 0x63, 0x8b, 0x43, 0x13, 0x81, 0xaa, 0xad, 0x95, 0x2c,
	0x6a, 0xc3, 0x0a, 0xbb, 0x6e, 0xf6, 0x79, 0x57, 0xf2, 0x7d, 0x2b, 0xea, 0x7f, 0xf2, 0xc8, 0x63,
	0x09, 0x27, 0x86, 0x66, 0x2c, 0x16, 0x9c, 0x19, 0x54, 0xae, 0x83, 0x79, 0x4f, 0x51, 0x6a, 0x90,
	0x3a, 0xd5, 0x79, 0x53, 0x2b, 0x25, 0xf9, 0xdb, 0x96, 0x73, 0x38, 0xc3, 0xd8, 0x86, 0xda, 0xf6,
	0xce, 0x18, 0xae, 0xc1, 0x9c, 0xdc, 0x76, 0xd5, 0x2b, 0xd0, 0x69, 0x6c, 0x0a, 0xee, 0x3f, 0x25,
	0xb9, 0xeb, 0x56, 0x72, 0x90, 0x2b, 0x3a, 0x4a, 0x4a, 0xb6, 0x20, 0x13, 0x1c, 0x64, 0x00, 0xae,
	0xce, 0x44, 0x61, 0x82, 0x1a, 0xf2, 0xca, 0x6b, 0xff, 0x96, 0xc4, 0x6d, 0xce, 0xb4, 0xbb, 0x92,
	0x1f, 0x14, 0xca, 0x16, 0xbb, 0xf3, 0xa5, 0x42, 0xd6, 0xf7, 0xd2, 0xd8, 0x88, 0xa1, 0x41, 0x05,
	0x07, 0xf6, 0xcc, 0xf8, 0xef, 0x3d, 0x52, 0x45, 0xc5, 0x82, 0x18, 0xa8, 0x60, 0x59, 0x4c, 0xb5,
	0x61, 0x06, 0xe6, 0xf7, 0xf0, 0xfe, 0xf4, 0xbc, 0xb1, 0xb1, 0xef, 0x66, 0xf4, 0xbb, 0x87, 0xaf,
	0x86, 0x76, 0xdc, 0xaa, 0xfd, 0xfd, 0x2e, 0xc8, 0x71, 0x7d, 0x96, 0xc5, 0x97, 0x62, 0xfe, 0x84,
	0x54, 0xed, 0x02, 0xaa, 0xad, 0x33, 0x3a, 0x71, 0xc7, 0x2c, 0x77, 0xb1, 0x5c, 0x76, 0xd3, 0xd9,
	0x11, 0x57, 0x70, 0x7e, 0x78, 0x1d, 0xee, 0xa3, 0x47, 0x1e, 0x25, 0x4c, 0xb1, 0x89, 0xa6, 0x06,
	0xa9, 0x8e, 0x99, 0x8e, 0x84, 0x0c, 0x73, 0xba, 0xfe, 0x0d, 0xbf, 0x52, 0x12, 0xdf, 0xcc, 0x31,
	0x23, 0x1c, 0x16, 0x10, 0x67, 0x45, 0xcf, 0x79, 0x79, 0xe7, 0x91, 0xed, 0x10, 0x33, 0x6b, 0x44,
	0x04, 0x2c, 0x42, 0x6d, 0x16, 0xf9, 0x58, 0x2d, 0xe9, 0xe3, 0x41, 0x88, 0xd9, 0x08, 0xfb, 0x39,
	0xe0, 0x9a, 0x87, 0x0f, 0x1e, 0x79, 0xc8, 0x52, 0x13, 0x59, 0x13, 0x47, 0x00, 0xa1, 0x62, 0x72,
	0xa1, 0x8b, 0xb2, 0x37, 0x40, 0xdd, 0x42, 0x46, 0xf8, 0xb2, 0x40, 0x5c, 0xf3, 0x61, 0xff, 0x8b,
	0x36, 0xec, 0xd8, 0xfe, 0x0c, 0x83, 0x34, 0x4d, 0x42, 0xc5, 0x38, 0x2c, 0x72, 0x52, 0xf6, 0x2e,
	0x68, 0x16, 0x98, 0x11, 0xbe, 0xc9, 0x21, 0x7f, 0x7a, 0xe9, 0x3d, 0xfb, 0x3a, 0xad, 0x7b, 0x67,
	0xd3, 0xba, 0xf7, 0x63, 0x5a, 0xf7, 0x3e, 0x5f, 0xd4, 0x97, 0xce, 0x2e, 0xea, 0x4b, 0xdf, 0x2f,
	0xea, 0x4b, 0x6f, 0xef, 0x5f, 0x3d, 0x21, 0x27, 0x73, 0xcf, 0x89, 0x39, 0x4d, 0x40, 0x8f, 0x2b,
	0xee, 0xe1, 0x78, 0xf2, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x82, 0x49, 0x07, 0x24, 0xa8, 0x06, 0x00,
	0x00,
}

func (m *BlockHeaderMerkleParts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *BlockHeaderMerkleParts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *BlockHeaderMerkleParts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.EvidenceAndProposerHash) > 0 {
		i -= len(m.EvidenceAndProposerHash)
		copy(dAtA[i:], m.EvidenceAndProposerHash)
		i = encodeVarintProof(dAtA, i, uint64(len(m.EvidenceAndProposerHash)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.LastResultsHash) > 0 {
		i -= len(m.LastResultsHash)
		copy(dAtA[i:], m.LastResultsHash)
		i = encodeVarintProof(dAtA, i, uint64(len(m.LastResultsHash)))
		i--
		dAtA[i] = 0x3a
	}
	if len(m.NextValidatorHashAndConsensusHash) > 0 {
		i -= len(m.NextValidatorHashAndConsensusHash)
		copy(dAtA[i:], m.NextValidatorHashAndConsensusHash)
		i = encodeVarintProof(dAtA, i, uint64(len(m.NextValidatorHashAndConsensusHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.LastBlockIdAndOther) > 0 {
		i -= len(m.LastBlockIdAndOther)
		copy(dAtA[i:], m.LastBlockIdAndOther)
		i = encodeVarintProof(dAtA, i, uint64(len(m.LastBlockIdAndOther)))
		i--
		dAtA[i] = 0x2a
	}
	if m.TimeNanoSecond != 0 {
		i = encodeVarintProof(dAtA, i, uint64(m.TimeNanoSecond))
		i--
		dAtA[i] = 0x20
	}
	if m.TimeSecond != 0 {
		i = encodeVarintProof(dAtA, i, uint64(m.TimeSecond))
		i--
		dAtA[i] = 0x18
	}
	if m.Height != 0 {
		i = encodeVarintProof(dAtA, i, uint64(m.Height))
		i--
		dAtA[i] = 0x10
	}
	if len(m.VersionAndChainIdHash) > 0 {
		i -= len(m.VersionAndChainIdHash)
		copy(dAtA[i:], m.VersionAndChainIdHash)
		i = encodeVarintProof(dAtA, i, uint64(len(m.VersionAndChainIdHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *MultiStoreProof) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *MultiStoreProof) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *MultiStoreProof) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.StakingToUpgradeStoresMerkleHash) > 0 {
		i -= len(m.StakingToUpgradeStoresMerkleHash)
		copy(dAtA[i:], m.StakingToUpgradeStoresMerkleHash)
		i = encodeVarintProof(dAtA, i, uint64(len(m.StakingToUpgradeStoresMerkleHash)))
		i--
		dAtA[i] = 0x32
	}
	if len(m.AuthToFeegrantStoresMerkleHash) > 0 {
		i -= len(m.AuthToFeegrantStoresMerkleHash)
		copy(dAtA[i:], m.AuthToFeegrantStoresMerkleHash)
		i = encodeVarintProof(dAtA, i, uint64(len(m.AuthToFeegrantStoresMerkleHash)))
		i--
		dAtA[i] = 0x2a
	}
	if len(m.GovToIcahostStoresMerkleHash) > 0 {
		i -= len(m.GovToIcahostStoresMerkleHash)
		copy(dAtA[i:], m.GovToIcahostStoresMerkleHash)
		i = encodeVarintProof(dAtA, i, uint64(len(m.GovToIcahostStoresMerkleHash)))
		i--
		dAtA[i] = 0x22
	}
	if len(m.ParamsToSlashingStoresMerkleHash) > 0 {
		i -= len(m.ParamsToSlashingStoresMerkleHash)
		copy(dAtA[i:], m.ParamsToSlashingStoresMerkleHash)
		i = encodeVarintProof(dAtA, i, uint64(len(m.ParamsToSlashingStoresMerkleHash)))
		i--
		dAtA[i] = 0x1a
	}
	if len(m.MintStoreMerkleHash) > 0 {
		i -= len(m.MintStoreMerkleHash)
		copy(dAtA[i:], m.MintStoreMerkleHash)
		i = encodeVarintProof(dAtA, i, uint64(len(m.MintStoreMerkleHash)))
		i--
		dAtA[i] = 0x12
	}
	if len(m.OracleIAVLStateHash) > 0 {
		i -= len(m.OracleIAVLStateHash)
		copy(dAtA[i:], m.OracleIAVLStateHash)
		i = encodeVarintProof(dAtA, i, uint64(len(m.OracleIAVLStateHash)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintProof(dAtA []byte, offset int, v uint64) int {
	offset -= sovProof(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *BlockHeaderMerkleParts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.VersionAndChainIdHash)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	if m.Height != 0 {
		n += 1 + sovProof(uint64(m.Height))
	}
	if m.TimeSecond != 0 {
		n += 1 + sovProof(uint64(m.TimeSecond))
	}
	if m.TimeNanoSecond != 0 {
		n += 1 + sovProof(uint64(m.TimeNanoSecond))
	}
	l = len(m.LastBlockIdAndOther)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	l = len(m.NextValidatorHashAndConsensusHash)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	l = len(m.LastResultsHash)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	l = len(m.EvidenceAndProposerHash)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	return n
}

func (m *MultiStoreProof) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.OracleIAVLStateHash)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	l = len(m.MintStoreMerkleHash)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	l = len(m.ParamsToSlashingStoresMerkleHash)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	l = len(m.GovToIcahostStoresMerkleHash)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	l = len(m.AuthToFeegrantStoresMerkleHash)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	l = len(m.StakingToUpgradeStoresMerkleHash)
	if l > 0 {
		n += 1 + l + sovProof(uint64(l))
	}
	return n
}

func sovProof(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozProof(x uint64) (n int) {
	return sovProof(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *BlockHeaderMerkleParts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: BlockHeaderMerkleParts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: BlockHeaderMerkleParts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VersionAndChainIdHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.VersionAndChainIdHash = append(m.VersionAndChainIdHash[:0], dAtA[iNdEx:postIndex]...)
			if m.VersionAndChainIdHash == nil {
				m.VersionAndChainIdHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Height", wireType)
			}
			m.Height = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Height |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeSecond", wireType)
			}
			m.TimeSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeSecond |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeNanoSecond", wireType)
			}
			m.TimeNanoSecond = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TimeNanoSecond |= uint32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastBlockIdAndOther", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastBlockIdAndOther = append(m.LastBlockIdAndOther[:0], dAtA[iNdEx:postIndex]...)
			if m.LastBlockIdAndOther == nil {
				m.LastBlockIdAndOther = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextValidatorHashAndConsensusHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextValidatorHashAndConsensusHash = append(m.NextValidatorHashAndConsensusHash[:0], dAtA[iNdEx:postIndex]...)
			if m.NextValidatorHashAndConsensusHash == nil {
				m.NextValidatorHashAndConsensusHash = []byte{}
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LastResultsHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LastResultsHash = append(m.LastResultsHash[:0], dAtA[iNdEx:postIndex]...)
			if m.LastResultsHash == nil {
				m.LastResultsHash = []byte{}
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EvidenceAndProposerHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EvidenceAndProposerHash = append(m.EvidenceAndProposerHash[:0], dAtA[iNdEx:postIndex]...)
			if m.EvidenceAndProposerHash == nil {
				m.EvidenceAndProposerHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *MultiStoreProof) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowProof
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: MultiStoreProof: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: MultiStoreProof: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OracleIAVLStateHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OracleIAVLStateHash = append(m.OracleIAVLStateHash[:0], dAtA[iNdEx:postIndex]...)
			if m.OracleIAVLStateHash == nil {
				m.OracleIAVLStateHash = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MintStoreMerkleHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MintStoreMerkleHash = append(m.MintStoreMerkleHash[:0], dAtA[iNdEx:postIndex]...)
			if m.MintStoreMerkleHash == nil {
				m.MintStoreMerkleHash = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ParamsToSlashingStoresMerkleHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ParamsToSlashingStoresMerkleHash = append(m.ParamsToSlashingStoresMerkleHash[:0], dAtA[iNdEx:postIndex]...)
			if m.ParamsToSlashingStoresMerkleHash == nil {
				m.ParamsToSlashingStoresMerkleHash = []byte{}
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GovToIcahostStoresMerkleHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GovToIcahostStoresMerkleHash = append(m.GovToIcahostStoresMerkleHash[:0], dAtA[iNdEx:postIndex]...)
			if m.GovToIcahostStoresMerkleHash == nil {
				m.GovToIcahostStoresMerkleHash = []byte{}
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthToFeegrantStoresMerkleHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AuthToFeegrantStoresMerkleHash = append(m.AuthToFeegrantStoresMerkleHash[:0], dAtA[iNdEx:postIndex]...)
			if m.AuthToFeegrantStoresMerkleHash == nil {
				m.AuthToFeegrantStoresMerkleHash = []byte{}
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field StakingToUpgradeStoresMerkleHash", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowProof
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthProof
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthProof
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.StakingToUpgradeStoresMerkleHash = append(m.StakingToUpgradeStoresMerkleHash[:0], dAtA[iNdEx:postIndex]...)
			if m.StakingToUpgradeStoresMerkleHash == nil {
				m.StakingToUpgradeStoresMerkleHash = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipProof(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthProof
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipProof(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowProof
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProof
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowProof
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthProof
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupProof
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthProof
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthProof        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowProof          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupProof = fmt.Errorf("proto: unexpected end of group")
)
