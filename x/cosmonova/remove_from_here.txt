package proof

import (
	"testing"

	ics23 "github.com/confio/ics23/go"
	storetypes "github.com/cosmos/cosmos-sdk/store/types"
	"github.com/stretchr/testify/require"
	"github.com/tendermint/tendermint/crypto/tmhash"
)

/*
query at localhost:26657/abci_query?path="/store/oracle/key"&data=0xc000000000000000&prove=true
{
    "jsonrpc": "2.0",
    "id": -1,
    "result": {
        "response": {
            "code": 0,
            "log": "",
            "info": "",
            "index": "0",
            "key": "wAAAAAAAAAA=",
            "value": null,
            "proofOps": {
                "ops": [
                    {
                        "type": "ics23:iavl",
                        "key": "wAAAAAAAAAA=",
                        "data": "EsMDCgjAAAAAAAAAABLpAQoVBQ1eS8RW3fDH5wAMd46Ih4w7Tw0SEhAIARIMCPLi8Z8GEMDCo+ABGgwIARgBIAEqBAAC+CUiKggBEiYCBPglIMOXtvsiuUKm461Mtf/w7SDhGVqba09R5L1VU2Y2HGeOICIsCAESBQQI5CYgGiEgubs5NRGOw8xaesuOPr7hPvlY1LNxamfQ5qwMMKn8l80iKggBEiYGDOQmIAqGoK3PW8B0zAWNvdrvKtLMf9f2nUvJ/8HUfbG+mLCDICIqCAESJgga+isgwVjErYVeGYGfWDSJS9zW6U1GPMLdybMMGp3k+lT5x+ggGsoBCgHwEgZvcmFjbGUaCwgBGAEgASoDAAICIiwIARIFAgTkJiAaISCUHaTOnLkieD5s4z9auzNnWGOptSWVA3As2DTxLWzmZyIqCAESJgQI5CYg5zZMcUYFSwmSAmz9ub37BrR2v3mWJNOfELL/z1YSFJggIioIARImBgzkJiAKhqCtz1vAdMwFjb3a7yrSzH/X9p1Lyf/B1H2xvpiwgyAiKggBEiYIGvorIMFYxK2FXhmBn1g0iUvc1ulNRjzC3cmzDBqd5PpU+cfoIA=="
                    },
                    {
                        "type": "ics23:simple",
                        "key": "b3JhY2xl",
                        "data": "CvwBCgZvcmFjbGUSIIM4YL+a7OkzwrQJ6EwUJEt+FIGnboCro+OQiGZs9UAFGgkIARgBIAEqAQAiJQgBEiEBCdlpWuQ2tdx5sWp9VcTA+Y2NRuM1L8YtFLgJeZsaDxUiJwgBEgEBGiCwlrc6YwUsF2ydIB3k9PiBO3bBHhoP0IHOJtO2nDIVPyIlCAESIQFjiuPaA6L1DtVd8DXecpB+lu/MQBzkzCZ6M7j3fc3/8iIlCAESIQGDasyPrY+cK/pMuiQihLx69Ek6gZUDJ+b6v80jTKvZfiInCAESAQEaIP3tTGQiclpWi3Qerkck9TntQJo1rBxSoN6oEp1iFuNJ"
                    }
                ]
            },
            "height": "2813",
            "codespace": ""
        }
    }
}
*/

func TestGetMultiStoreProof(t *testing.T) {
	key := []byte("cosmonova")
	data := base64ToBytes(
		"CoECCgljb3Ntb25vdmESIOOwxEKY/BwUmvv0yJlvuSQnrkHkZJuTTKSVmRt4UrhVGgkIARgBIAEqAQAiJQgBEiEBjHzqtksfOg8xTgoaz4aOg6S2NVrYB59ooGBU7MLQBEYiJwgBEgEBGiDj37cYlgeu/w2/r07ZInk69oBvzw3Pnlcam9E8VWpXXiIlCAESIQHoePUPHz3Z9mhrND3ZvG0kzJjRm2o7ocyZuc1eH9KQryInCAESAQEaIGs0pe0n6Di2I8nlpolugghKYpmVZkieucwAudf9N/cGIicIARIBARogVlwYishJQL1PAeVZq0/UZKSMRVk9ySbkuWl+XyA6MTo=",
	)

	var multistoreOps storetypes.CommitmentOp
	proof := &ics23.CommitmentProof{}
	err := proof.Unmarshal(data)
	require.Nil(t, err)

	multistoreOps = storetypes.NewSimpleMerkleCommitmentOp(key, proof)
	multistoreEp := multistoreOps.Proof.GetExist()
	require.NotNil(t, multistoreEp)

	var expectAppHash []byte
	expectAppHash, err = multistoreEp.Calculate()
	pl(expectAppHash, "expected hash")
	// [205 92 232 67 61 52 128 157 51 63 97 57 30 81 96 182 25 131 46 255 141 51 247 244 183 153 101 137 87 245 72 181]
	// [205 92 232 67 61 52 128 157 51 63 97 57 30 81 96 182 25 131 46 255 141 51 247 244 183 153 101 137 87 245 72 181]
	// actual hash

	require.Nil(t, err)
	pl(multistoreEp)
	pl("!!!!!!!!!!!! in test")
	m := GetMultiStoreProof(multistoreEp)
	pl("!!!!!!!!!!!! back in test")
	pl(m.GetOracleIAVLStateHash())
	pl(m.GovToIcahostStoresMerkleHash)
	m.encodeToEthFormat()

	prefix := []byte{}
	prefix = append(prefix, 9)      // key length
	prefix = append(prefix, key...) // key to result of request #1
	prefix = append(prefix, 32)     // size of result hash must be 32
	pl("init")
	// [242 201 200 109 97 54 231 151 156 197 36 216 254 252 220 251 66 217 244 29 233 75 138 248 30 171 82 141 210 227 112 180]
	// [242 201 200 109 97 54 231 151 156 197 36 216 254 252 220 251 66 217 244 29 233 75 138 248 30 171 82 141 210 227 112 180]

	// [110 204 66 67 19 214 18 98 173 207 181 220 10 46 197 81 83 26 11 105 222 115 247 38 231 214 50 253 161 57 135 193]
	// [110 204 66 67 19 214 18 98 173 207 181 220 10 46 197 81 83 26 11 105 222 115 247 38 231 214 50 253 161 57 135 193]

	// [85 89 190 124 41 228 139 15 71 222 158 11 228 171 85 123 25 83 5 9 56 15 174 18 75 107 231 95 168 48 230 30]
	// [85 89 190 124 41 228 139 15 71 222 158 11 228 171 85 123 25 83 5 9 56 15 174 18 75 107 231 95 168 48 230 30]
	// [171 93 6 191 248 230 248 47 46 112 4 38 111 107 235 124 132 99 31 152 130 220 231 172 130 187 186 239 98 99 248 133] right result
	// pl(m.AuthToFeegrantStoresMerkleHash.Bytes())
	// pl(
	// 	innerHash(innerHash(
	// 		innerHash(
	// 			m.GovToIcahostStoresMerkleHash,
	// 			innerHash(
	// 				innerHash(
	// 					m.MintStoreMerkleHash,
	// 					leafHash(append(prefix, tmhash.Sum(m.OracleIAVLStateHash)...)),
	// 				),
	// 				m.ParamsToSlashingStoresMerkleHash,
	// 			),
	// 		),
	// 		m.AuthToFeegrantStoresMerkleHash,
	// 	),
	// 		m.StakingToUpgradeStoresMerkleHash),
	// )
	// pl("init")
	apphash := innerHash(innerHash(
		innerHash(
			m.GovToIcahostStoresMerkleHash,
			innerHash(
				innerHash(
					m.MintStoreMerkleHash,
					leafHash(append(prefix, tmhash.Sum(m.OracleIAVLStateHash)...)),
				),
				m.ParamsToSlashingStoresMerkleHash,
			),
		),
		m.AuthToFeegrantStoresMerkleHash,
	),
		m.StakingToUpgradeStoresMerkleHash)
	pl(apphash)
	// require.Equal(t, expectAppHash, apphash)
}

// expected path
// [
// hash:SHA256 prefix:"\001\214|\352\266K\037:\0171N\n\032\317\206\216\203\244\2665Z\330\007\237h\240`T\354\302\320\004F"
// hash:SHA256 prefix:"\001" suffix:"\343\337\267\030\226\007\256\377\r\277\257N\331\"y:\366\200o\317\r\317\236W\032\233\321<UjW^"
// hash:SHA256 prefix:"\001\350x\365\017\037=\331\366hk4=\331\274m$\314\230\321\233j;\241\314\231\271\315^\037\322\220\257"

// hash:SHA256 prefix:"\001" suffix:"k4\245\355'\3508\266#\311\345\246\211n\202\010Jb\231\225fH\236\271\314\000\271\327\3757\367\006"
// hash:SHA256 prefix:"\001" suffix:"V\\\030\212\310I@\275O\001\345Y\253O\324d\244\214EY=\311&\344\271i~_ :1:" ]
// [hash:SHA256 prefix:"\001\214|\352\266K\037:\0171N\n\032\317\206\216\203\244\2665Z\330\007\237h\240`T\354\302\320\004F"  hash:SHA256 prefix:"\001" suffix:"\343\337\267\030\226\007\256\377\r\277\257N\331\"y:\366\200o\317\r\317\236W\032\233\321<UjW^"  hash:SHA256 prefix:"\001\350x\365\017\037=\331\366hk4=\331\274m$\314\230\321\233j;\241\314\231\271\315^\037\322\220\257"  hash:SHA256 prefix:"\001" suffix:"k4\245\355'\3508\266#\311\345\246\211n\202\010Jb\231\225fH\236\271\314\000\271\327\3757\367\006"  hash:SHA256 prefix:"\001" suffix:"V\\\030\212\310I@\275O\001\345Y\253O\324d\244\214EY=\311&\344\271i~_ :1:" ]

// [184 65 112 131 167 120 168 243 41 141 192 107 6 239 172 117 107 73 29 163 244 117 112 43 76 137 72 70 14 201 67 23] left
// [86 92 24 138 200 73 64 189 79 1 229 89 171 79 212 100 164 140 69 89 61 201 38 228 185 105 126 95 32 58 49 58] right

// preimage0 [1 140 124 234 182 75 31 58 15 49 78 10 26 207 134 142 131 164 182 53 90 216 7 159 104 160 96 84 236 194 208 4 70]
// preimage1 [1 140 124 234 182 75 31 58 15 49 78 10 26 207 134 142 131 164 182 53 90 216 7 159 104 160 96 84 236 194 208 4 70 37 204 240 128 57 13 209 99 131 192 209 225 152 244 135 62 24 52 149 193 74 5 129 198 183 199 64 141 182 244 57 100]
// preimage2 [1 140 124 234 182 75 31 58 15 49 78 10 26 207 134 142 131 164 182 53 90 216 7 159 104 160 96 84 236 194 208 4 70 37 204 240 128 57 13 209 99 131 192 209 225 152 244 135 62 24 52 149 193 74 5 129 198 183 199 64 141 182 244 57 100]
// [140 124 234 182 75 31 58 15 49 78 10 26 207 134 142 131 164 182 53 90 216 7 159 104 160 96 84 236 194 208 4 70] left
// [37 204 240 128 57 13 209 99 131 192 209 225 152 244 135 62 24 52 149 193 74 5 129 198 183 199 64 141 182 244 57 100] right
// res
// [242 201 200 109 97 54 231 151 156 197 36 216 254 252 220 251 66 217 244 29 233 75 138 248 30 171 82 141 210 227 112 180]
// hash:SHA256 prefix:"\001" suffix:"\343\337\267\030\226\007\256\377\r\277\257N\331\"y:\366\200o\317\r\317\236W\032\233\321<UjW^"
// preimage0 [1]
// preimage1 [1 242 201 200 109 97 54 231 151 156 197 36 216 254 252 220 251 66 217 244 29 233 75 138 248 30 171 82 141 210 227 112 180]
// preimage2 [1 242 201 200 109 97 54 231 151 156 197 36 216 254 252 220 251 66 217 244 29 233 75 138 248 30 171 82 141 210 227 112 180 227 223 183 24 150 7 174 255 13 191 175 78 217 34 121 58 246 128 111 207 13 207 158 87 26 155 209 60 85 106 87 94]
// [242 201 200 109 97 54 231 151 156 197 36 216 254 252 220 251 66 217 244 29 233 75 138 248 30 171 82 141 210 227 112 180] left
// [227 223 183 24 150 7 174 255 13 191 175 78 217 34 121 58 246 128 111 207 13 207 158 87 26 155 209 60 85 106 87 94] right
// res
// [110 204 66 67 19 214 18 98 173 207 181 220 10 46 197 81 83 26 11 105 222 115 247 38 231 214 50 253 161 57 135 193]
// hash:SHA256 prefix:"\001\350x\365\017\037=\331\366hk4=\331\274m$\314\230\321\233j;\241\314\231\271\315^\037\322\220\257"
// preimage0 [1 232 120 245 15 31 61 217 246 104 107 52 61 217 188 109 36 204 152 209 155 106 59 161 204 153 185 205 94 31 210 144 175]
// preimage1 [1 232 120 245 15 31 61 217 246 104 107 52 61 217 188 109 36 204 152 209 155 106 59 161 204 153 185 205 94 31 210 144 175 110 204 66 67 19 214 18 98 173 207 181 220 10 46 197 81 83 26 11 105 222 115 247 38 231 214 50 253 161 57 135 193]
// preimage2 [1 232 120 245 15 31 61 217 246 104 107 52 61 217 188 109 36 204 152 209 155 106 59 161 204 153 185 205 94 31 210 144 175 110 204 66 67 19 214 18 98 173 207 181 220 10 46 197 81 83 26 11 105 222 115 247 38 231 214 50 253 161 57 135 193]
// [232 120 245 15 31 61 217 246 104 107 52 61 217 188 109 36 204 152 209 155 106 59 161 204 153 185 205 94 31 210 144 175] left
// [110 204 66 67 19 214 18 98 173 207 181 220 10 46 197 81 83 26 11 105 222 115 247 38 231 214 50 253 161 57 135 193] right
// res
// [85 89 190 124 41 228 139 15 71 222 158 11 228 171 85 123 25 83 5 9 56 15 174 18 75 107 231 95 168 48 230 30]
// hash:SHA256 prefix:"\001" suffix:"k4\245\355'\3508\266#\311\345\246\211n\202\010Jb\231\225fH\236\271\314\000\271\327\3757\367\006"
// preimage0 [1]
// preimage1 [1 85 89 190 124 41 228 139 15 71 222 158 11 228 171 85 123 25 83 5 9 56 15 174 18 75 107 231 95 168 48 230 30]
// preimage2 [1 85 89 190 124 41 228 139 15 71 222 158 11 228 171 85 123 25 83 5 9 56 15 174 18 75 107 231 95 168 48 230 30 107 52 165 237 39 232 56 182 35 201 229 166 137 110 130 8 74 98 153 149 102 72 158 185 204 0 185 215 253 55 247 6]
// [] left
// [85 89 190 124 41 228 139 15 71 222 158 11 228 171 85 123 25 83 5 9 56 15 174 18 75 107 231 95 168 48 230 30] right
// res
// [171 93 6 191 248 230 248 47 46 112 4 38 111 107 235 124 132 99 31 152 130 220 231 172 130 187 186 239 98 99 248 133]
// hash:SHA256 prefix:"\001" suffix:"V\\\030\212\310I@\275O\001\345Y\253O\324d\244\214EY=\311&\344\271i~_ :1:"
// preimage0 [1]
// preimage1 [1 171 93 6 191 248 230 248 47 46 112 4 38 111 107 235 124 132 99 31 152 130 220 231 172 130 187 186 239 98 99 248 133]
// preimage2 [1 171 93 6 191 248 230 248 47 46 112 4 38 111 107 235 124 132 99 31 152 130 220 231 172 130 187 186 239 98 99 248 133 86 92 24 138 200 73 64 189 79 1 229 89 171 79 212 100 164 140 69 89 61 201 38 228 185 105 126 95 32 58 49 58]


package proof

import (
	ics23 "github.com/confio/ics23/go"
	"github.com/ethereum/go-ethereum/common"
	tmbytes "github.com/tendermint/tendermint/libs/bytes"
)

// MultiStoreProofEthereum is an Ethereum version of MultiStoreProof for solidity ABI-encoding.
type MultiStoreProofEthereum struct {
	OracleIAVLStateHash              common.Hash
	MintStoreMerkleHash              common.Hash
	ParamsToSlashingStoresMerkleHash common.Hash
	GovToIcahostStoresMerkleHash     common.Hash
	AuthToFeegrantStoresMerkleHash   common.Hash
	StakingToUpgradeStoresMerkleHash common.Hash
}

func (m *MultiStoreProof) encodeToEthFormat() MultiStoreProofEthereum {
	return MultiStoreProofEthereum{
		OracleIAVLStateHash:              common.BytesToHash(m.OracleIAVLStateHash),
		MintStoreMerkleHash:              common.BytesToHash(m.MintStoreMerkleHash),
		ParamsToSlashingStoresMerkleHash: common.BytesToHash(m.ParamsToSlashingStoresMerkleHash),
		GovToIcahostStoresMerkleHash:     common.BytesToHash(m.GovToIcahostStoresMerkleHash),
		AuthToFeegrantStoresMerkleHash:   common.BytesToHash(m.AuthToFeegrantStoresMerkleHash),
		StakingToUpgradeStoresMerkleHash: common.BytesToHash(m.StakingToUpgradeStoresMerkleHash),
	}
}

// GetMultiStoreProof compacts Multi store proof from Tendermint to MultiStoreProof version.
func GetMultiStoreProof(multiStoreEp *ics23.ExistenceProof) MultiStoreProof {
	return MultiStoreProof{
		OracleIAVLStateHash:              tmbytes.HexBytes(multiStoreEp.Value),
		MintStoreMerkleHash:              tmbytes.HexBytes(multiStoreEp.Path[0].Prefix[1:]),
		ParamsToSlashingStoresMerkleHash: tmbytes.HexBytes(multiStoreEp.Path[1].Suffix),
		GovToIcahostStoresMerkleHash:     tmbytes.HexBytes(multiStoreEp.Path[2].Prefix[1:]),
		AuthToFeegrantStoresMerkleHash:   tmbytes.HexBytes(multiStoreEp.Path[3].Suffix),
		StakingToUpgradeStoresMerkleHash: tmbytes.HexBytes(multiStoreEp.Path[4].Suffix),
	}
}


package proof

import (
	"fmt"
	"testing"

	"github.com/stretchr/testify/require"
	tmbytes "github.com/tendermint/tendermint/libs/bytes"
	tmversion "github.com/tendermint/tendermint/proto/tendermint/version"
	"github.com/tendermint/tendermint/types"
)

/*
	{
		block_id: {
			hash: "3489F21785ACE1CE4214CB2B57F3A98DC0B7377D1BA1E1180B6E199E33B0FC5A",
			parts: {
				total: 1,
				hash: "6BF91EFBA26A4CD86EBBD0E54DCFC9BD2C790859CFA96215661A47E4921A6301"
			}
		},
		block: {
			header: {
				version: {
					block: "11"
				},
				chain_id: "bandchain",
				height: "25000",
				time: "2021-08-25T00:05:31.290650376Z",
				last_block_id: {
					hash: "622A4600128DECC6C42E471F06F00C654785485D5AB4437556F41743DC4684C8",
					parts: {
						total: 1,
						hash: "733EDAE763A4635509BE9E55E06A2CBF726056A0898B6B4D3AF74683ECCF3475"
					}
				},
				last_commit_hash: "021C8BBD047747AE943C5F7991B6848DE371B313FF3C15E5B2EDA94DD834BB42",
				data_hash: "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855",
				validators_hash: "113928F64B9B2A1F1A58D87C93147D822CF2069309B55D47717700D4074A43B6",
				next_validators_hash: "113928F64B9B2A1F1A58D87C93147D822CF2069309B55D47717700D4074A43B6",
				consensus_hash: "188E4357E7B1201E6C2B418759CB8246FAB30CF2FFA87433E21690B7BC8BC88C",
				app_hash: "37D2CA95F226A7AFE3C41DE288F8158B737E78C4B733B1CCB0061D3236E926BE",
				last_results_hash: "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855",
				evidence_hash: "E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855",
				proposer_address: "F23391B5DBF982E37FB7DADEA64AAE21CAE4C172"
			}
		}
	}
*/
func TestBlockHeaderMerkleParts(t *testing.T) {
	// Copy block header Merkle Part here
	fmt.Println("Im in here")
	header := types.Header{
		Version: tmversion.Consensus{Block: 11},
		ChainID: "cosmonova",
		Height:  1,
		Time:    parseTime("2023-08-23T20:20:21.74714Z"),
		LastBlockID: types.BlockID{
			Hash: hexToBytes(""),
			PartSetHeader: types.PartSetHeader{
				Total: 0,
				Hash:  hexToBytes(""),
			},
		},
		LastCommitHash:     hexToBytes("E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855"),
		DataHash:           hexToBytes("E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855"),
		ValidatorsHash:     hexToBytes("6E4D20E28EB290CD11623203FBF892DF935F647E67253B0B0C2EDF9B7A085622"),
		NextValidatorsHash: hexToBytes("6E4D20E28EB290CD11623203FBF892DF935F647E67253B0B0C2EDF9B7A085622"),
		ConsensusHash:      hexToBytes("048091BC7DDC283F77BFBF91D73C44DA58C3DF8A9CBC867405D8B7F3DAADA22F"),
		AppHash:            hexToBytes("E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855"),
		LastResultsHash:    hexToBytes("E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855"),
		EvidenceHash:       hexToBytes("E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855"),
		ProposerAddress:    hexToBytes("5EE304CED5F7DCCE2C7141E9707FD675D9C2EA91"),
	}
	blockMerkleParts := GetBlockHeaderMerkleParts(&header)
	fmt.Println(blockMerkleParts.encodeToEthFormat())
	expectBlockHash := hexToBytes("FD0357CA4155F40B604A249D2F71743E327E2AFAD733018007731CAE6651DF00")
	appHash := tmbytes.HexBytes(hexToBytes("E3B0C44298FC1C149AFBF4C8996FB92427AE41E4649B934CA495991B7852B855"))

	// Verify code
	blockHash := innerHash(
		innerHash(
			innerHash(
				blockMerkleParts.VersionAndChainIdHash,
				innerHash(
					leafHash(cdcEncode(header.Height)),
					leafHash(encodeTime(header.Time)),
				),
			),
			blockMerkleParts.LastBlockIdAndOther,
		),
		innerHash(
			innerHash(
				blockMerkleParts.NextValidatorHashAndConsensusHash,
				innerHash(
					leafHash(cdcEncode(appHash)),
					blockMerkleParts.LastResultsHash,
				),
			),
			blockMerkleParts.EvidenceAndProposerHash,
		),
	)
	fmt.Println(expectBlockHash)
	fmt.Println(blockHash)
	require.Equal(t, expectBlockHash, blockHash)
}


